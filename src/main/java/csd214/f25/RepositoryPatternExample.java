// see https://docs.google.com/document/d/1zXTIkXqs_M6wpQFIT3H0-rgIAOl5OcQKRuHS-N0OSyM/edit?tab=t.0
package csd214.f25;

import java.util.*;


// Define a simple entity
class Product {
    private Long id;
    private String name;
    private double price;

    public Product(Long id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "Product{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
}


// 1. Define the Repository Interface
interface Repository<T> {
    Optional<?> findById(Long id);
    List<?> findAll();
    T save(T product);
    void deleteById(Long id);
}
// 2. Implement the Repository with a specific data source (In-Memory)
class InMemoryProductRepository implements Repository<Product> {

    private final Map<Long, Product> products = new HashMap<>();
    private Long nextId = 1L; // Simple ID generation for demo purposes

    @Override
    public Optional<Product> findById(Long id) {
        return Optional.ofNullable(products.get(id));
    }

    @Override
    public List<Product> findAll() {
        return new ArrayList<>(products.values());
    }

    @Override
    public Product save(Product product) {
        if (product.getId() == null) {
            product = new Product(nextId++, product.getName(), product.getPrice()); // Assign ID if it's new
        }
        products.put(product.getId(), product);
        return product;
    }

    @Override
    public void deleteById(Long id) {
        products.remove(id);
    }
}


// 3. Implement the Repository with a different data source (Simulated Database)
//    This shows how the Repository pattern allows switching implementations easily
class DatabaseProductRepository implements Repository<Product> {

    // Simulate a database connection (replace with actual JDBC/JPA code)
    // In a real application, this would connect to a database using JDBC, JPA, or other ORM.

    @Override
    public Optional<Product> findById(Long id) {
        // Simulate database query
        System.out.println("Database: Fetching product with ID " + id);
        // In a real application, you would execute a SELECT query here.
        //  For this example, we'll always return an empty Optional.
        return Optional.empty(); // Simulate "not found" in the database
    }

    @Override
    public List<Product> findAll() {
        // Simulate database query
        System.out.println("Database: Fetching all products");
        // In a real application, you would execute a SELECT query here.
        return new ArrayList<>(); // Simulate an empty database
    }

    @Override
    public Product save(Product product) {
        // Simulate database insert/update
        System.out.println("Database: Saving product " + product);
        // In a real application, you would execute an INSERT or UPDATE query here.
        return product;
    }

    @Override
    public void deleteById(Long id) {
        // Simulate database delete
        System.out.println("Database: Deleting product with ID " + id);
        // In a real application, you would execute a DELETE query here.
    }
}
// 4. Service Layer (Uses the Repository)
class ProductService {

    private final Repository<Product> productRepository;

    public ProductService(Repository<Product> productRepository) {
        this.productRepository = productRepository;
    }

    public Optional<Product> getProduct(Long id) {
        return (Optional<Product>) productRepository.findById(id);
    }

    public List<Product> getAllProducts() {
        return (List<Product>) productRepository.findAll();
    }

    public Product createProduct(String name, double price) {
        Product newProduct = new Product(null, name, price); // ID will be generated by repository
        return productRepository.save(newProduct);
    }

    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }
}


// 5. Example Usage (Demonstrates the benefits)
public class RepositoryPatternExample {

    public static void main(String[] args) {
        // Benefit 1:  Abstracts data access logic
        // Choose which repository to use at runtime without changing the service layer.
        // We can easily switch between InMemory and Database implementations.

        // Use in-memory repository for testing or development
        Repository<Product> inMemoryRepository = new InMemoryProductRepository();
        ProductService inMemoryProductService = new ProductService(inMemoryRepository);

        // Use database repository for production
        Repository<Product> databaseRepository = new DatabaseProductRepository();
        ProductService databaseProductService = new ProductService(databaseRepository);


        // Benefit 2:  Decoupling and Testability

        // Now, let's use the in-memory service:
        System.out.println("Using In-Memory Repository:");
        Product createdProduct = inMemoryProductService.createProduct("Laptop", 1200.00);
        System.out.println("Created product: " + createdProduct);
        inMemoryProductService.getAllProducts().forEach(System.out::println);

        // You can easily test the ProductService with a mock ProductRepository.
        // (Example of a mock is not included here for brevity, but you can easily create one.)


        // Benefit 3: Centralized data access logic
        // All data access logic is encapsulated in the repositories.
        // This makes it easier to maintain and update the data access logic.
        // No data access code resides in the service layer.


        // Now, let's use the database service:
        System.out.println("\nUsing Database Repository:");
        Product createdProductDB = databaseProductService.createProduct("Mouse", 25.00);
        System.out.println("Created product (in database): " + createdProductDB); // Output will be to the console showing DB interaction

        //The key takeaway is: the `ProductService` code *doesn't change at all* to work with
        //different data sources.  That's the power of the Repository pattern!
    }
}